package main

import (
	"bytes"
	"errors"
	"flag"
	"log"

	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io"
	"os"
	"time"
	"strings"
	"text/template"
)

type StringerAction func(string, string) error

func main() {
	fmt.Println("time start: ", time.Now())
	// logger := log.New(os.Stdout, "[LOG]", log.LstdFlags)
	log.SetOutput(os.Stdout)
	log.SetFlags(log.LstdFlags | log.Lmsgprefix)
	log.SetPrefix("[LOG] ")

	rootPath := flag.String("p", ".", "path of the root parsing directory")
	isRecursion := flag.Bool("r", false, "enable recursion")
	isSavedToStdout := flag.Bool("n", false, "display stringer code gen to stdout in place of disk")
	isHelp := flag.Bool("h", false, "display this help")

	flag.Parse()

	if *isHelp {
		flag.PrintDefaults()
		os.Exit(0)
	}

	var action StringerAction = saveToDisk
	if *isSavedToStdout { action = displayToStdout }

	stringer(*rootPath, *isRecursion, action)

	fmt.Println("time end: ", time.Now())

	return
}

func stringer(dirname string, isRecursive bool, action StringerAction) error {
	err := os.Chdir(dirname)
	if err != nil { return err }
	defer os.Chdir("..")

	dirs, err := os.ReadDir(".")
	if err != nil {
		log.Println("error while reading directory, ", err.Error())
		return err
	}

	for _, dir := range dirs {

		if isRecursive && dir.IsDir() {
			subDir := dir.Name()
			err = stringer(subDir, isRecursive, action)

		} else if dir.Type().IsRegular() && strings.HasSuffix(dir.Name(), ".go"){

			filename := dir.Name()
			file, err := os.Open(filename)

			if err != nil {
				log.Println("error while opening file, ", err.Error())
				continue
			}

			defer file.Close()
			fileContent, err := io.ReadAll(file)
			if err != nil {
				log.Println("error while reading file, ", err.Error())
				continue
			}

			newContent, err := buildStringerForStructure(fileContent)
			if err != nil {
				log.Println("error while generating stringer, ", err.Error())
				continue
			}

			formatedContent, err := format.Source([]byte(newContent))
			if err != nil {
				log.Println("error while formating the generated stringer, ", err.Error())
				continue
			}

			err = action(filename, string(formatedContent))
			if err != nil {
				log.Println("error while applying change, ", err.Error())
				continue
			}
		}
	}

	return err
}

func buildStringerForStructure (content []byte) (string, error) {
	fileSet := token.NewFileSet()
	f, _ := parser.ParseFile(fileSet, "", content, parser.SkipObjectResolution)

	var err error
	finalContent := ""

	for _, decl := range f.Decls {
		if declaration, ok := decl.(*ast.GenDecl); ok {

			if declaration.Tok == token.TYPE {
				typeName := ""
				fieldNames := []string{}

				_ = typeName
				_ = fieldNames

				for _, spec := range declaration.Specs {
					typeDeclaration, ok := spec.(*ast.TypeSpec)
					if !ok { continue }

					typeName = typeDeclaration.Name.Name

					types, ok := typeDeclaration.Type.(*ast.StructType)
					if !ok { continue }

					for _, field := range types.Fields.List {
						fieldNames = append(fieldNames, field.Names[0].Name)
					}
					
				}

				src := ` func (v {{.typeName}}) String() string {
					return fmt.Sprintf("{{.typeName}}: { {{range .fieldNames}} {{.}}: %s, {{end}} {{.lastField}}: %s }", {{range .fieldNames}} v.{{.}}, {{end}} v.{{.lastField}}) 
					}`

				tmpl, errLocal := template.New("stringer").Parse(src)
				if errLocal != nil {
					log.Println("an error occured while parsing template, ", errLocal.Error())
					err = errLocal
					continue
				}

				str := bytes.NewBufferString("")

				size := len(fieldNames)
				if size == 0 { continue }
				
				value := map[string]any{
					"typeName": typeName,
					"fieldNames": fieldNames[:size - 1],
					"lastField": fieldNames[size -1],
				}

				tmpl.Execute(str, value)

				finalContent += str.String() + "\n\n"
			}
		}
	}

	if len(finalContent) == 0 {
		return finalContent, errors.New("no struct found in this file")
	}

	packageName := f.Name.Name
	finalContent = "// Code generated by stringer; DO NOT EDIT." +
		"\n" + "// timestamp: " + time.Now().String() + "\n\n" + "package " + packageName + 
		"\n\n" + "import \"fmt\"" + "\n\n" + finalContent

	return finalContent, err
}

func saveToDisk(fileName, fileContent string) error {
	size := len(fileName) - len(".go")
	if size < 0 {
		return fmt.Errorf("filename '" + fileName + "' do not have a '.go' extension")
	}

	newFileName := fileName[:size] + "_fmt.gen.go"

	newFile, err := os.Create(newFileName)
	if err != nil {
		return fmt.Errorf("error while creating file, ", err.Error())
	}

	defer newFile.Close()

	_, err = io.WriteString(newFile, fileContent)
	if err != nil {
		return fmt.Errorf("error while writing stringer to file, ", err.Error())
	}

	return nil
}

func displayToStdout(fileName, fileContent string) error {
	fmt.Printf("-- file: %s\n%s", fileName, fileContent)

	return nil
}

