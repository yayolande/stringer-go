package main

import (
	"bytes"
	"flag"
	"io/fs"
	"log"
	"path/filepath"
	"sync"

	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io"
	"os"
	"strings"

	"text/template"
	"time"
)

type StringerAction func(string, string) error
var channel	chan bool
var wg sync.WaitGroup

func main() {
	timeStart := time.Now()
	// logger := log.New(os.Stdout, "[LOG]", log.LstdFlags)
	log.SetOutput(os.Stdout)
	log.SetFlags(log.LstdFlags | log.Lmsgprefix)
	log.SetPrefix("[LOG] ")

	rootPath := flag.String("p", ".", "path of the root parsing directory")
	isRecursion := flag.Bool("r", false, "enable recursion")
	isSavedToStdout := flag.Bool("n", false, "display stringer code gen to stdout in place of disk")
	isHelp := flag.Bool("h", false, "display this help")
	coreCount := flag.Int("c", 4, "select paralell core processing")

	flag.Parse()

	if *isHelp {
		flag.PrintDefaults()
		os.Exit(0)
	}

	channel = make(chan bool, *coreCount)
	wg = sync.WaitGroup{}

	var action StringerAction = saveToDisk
	if *isSavedToStdout { action = displayToStdout }

	// Main processing function
	stringer(*rootPath, *isRecursion, action)

	// Wait for all the remaining goroutine to complete before moving forward
	close(channel)
	wg.Wait()

	if len(channel) > 0 {
		log.Println("fatal error, not all goroutines completed execution")
	}
	
	timeEnd := time.Now()
	elapsedTime := timeEnd.Sub(timeStart)
	fmt.Println("elapsed time: ", elapsedTime)

	return
}

func stringer(dirname string, isRecursive bool, action StringerAction) error {
	dirs, err := os.ReadDir(dirname)
	if err != nil {
		log.Println("error while reading directory, ", err.Error())
		return err
	}

	for _, dir := range dirs {

		if isRecursive && dir.IsDir() {
			subDir := filepath.Join(dirname, dir.Name())
			err = stringer(subDir, isRecursive, action)

		} else if dir.Type().IsRegular() && strings.HasSuffix(dir.Name(), ".go"){
			wg.Add(1)

			go func(dir fs.DirEntry) {
				defer wg.Done()
				defer func() { <- channel }()

				filename := filepath.Join(dirname, dir.Name())
				file, err := os.Open(filename)

				if err != nil {
					log.Println("error while opening file, ", filename, err.Error())
					return
				}

				defer file.Close()
				fileContent, err := io.ReadAll(file)
				if err != nil {
					log.Println("error while reading file, ", err.Error())
					return
				}

				newContent, err := buildStringerForStructure(fileContent)
				if err != nil {
					log.Println("error while generating stringer, ", err.Error())
					return
				}

				if len(newContent) == 0 {
					return
				}

				formatedContent, err := format.Source([]byte(newContent))
				if err != nil {
					log.Println("error while formating the generated stringer, ", err.Error())
					return
				}

				err = action(filename, string(formatedContent))
				if err != nil {
					log.Println("error while applying change, ", err.Error())
					return
				}

			}(dir)

			channel <- true
		}
	}

	return err
}

func buildStringerForStructure (content []byte) (string, error) {
	fileSet := token.NewFileSet()
	f, _ := parser.ParseFile(fileSet, "", content, parser.SkipObjectResolution)

	var err error
	finalContent := ""

	for _, decl := range f.Decls {
		if declaration, ok := decl.(*ast.GenDecl); ok {

			if declaration.Tok == token.TYPE {
				typeName := ""
				fieldNames := []string{}

				_ = typeName
				_ = fieldNames

				for _, spec := range declaration.Specs {
					typeDeclaration, ok := spec.(*ast.TypeSpec)
					if !ok { continue }

					typeName = typeDeclaration.Name.Name

					types, ok := typeDeclaration.Type.(*ast.StructType)
					if !ok { continue }

					for _, field := range types.Fields.List {
						fieldNames = append(fieldNames, field.Names[0].Name)
					}
					
				}

				src := ` func (v {{.typeName}}) String() string {
					return fmt.Sprintf("{{.typeName}}: { {{range .fieldNames}} {{.}}: %s, {{end}} {{.lastField}}: %s }", {{range .fieldNames}} v.{{.}}, {{end}} v.{{.lastField}}) 
					}`

				tmpl, errLocal := template.New("stringer").Parse(src)
				if errLocal != nil {
					log.Println("an error occured while parsing template, ", errLocal.Error())
					err = errLocal
					continue
				}

				str := bytes.NewBufferString("")

				size := len(fieldNames)
				if size == 0 { continue }
				
				value := map[string]any{
					"typeName": typeName,
					"fieldNames": fieldNames[:size - 1],
					"lastField": fieldNames[size -1],
				}

				tmpl.Execute(str, value)

				finalContent += str.String() + "\n\n"
			}
		}
	}

	if len(finalContent) == 0 {
		return finalContent, nil
	}

	packageName := f.Name.Name
	finalContent = "// Code generated by stringer; DO NOT EDIT." +
		"\n" + "// timestamp: " + time.Now().String() + "\n\n" + "package " + packageName + 
		"\n\n" + "import \"fmt\"" + "\n\n" + finalContent

	return finalContent, err
}

func saveToDisk(fileName, fileContent string) error {
	size := len(fileName) - len(".go")
	if size < 0 {
		return fmt.Errorf("filename '" + fileName + "' do not have a '.go' extension")
	}

	newFileName := fileName[:size] + "_fmt.gen.go"

	newFile, err := os.Create(newFileName)
	if err != nil {
		return fmt.Errorf("error while creating file, ", err.Error())
	}

	defer newFile.Close()

	_, err = io.WriteString(newFile, fileContent)
	if err != nil {
		return fmt.Errorf("error while writing stringer to file, ", err.Error())
	}

	return nil
}

func displayToStdout(fileName, fileContent string) error {
	fmt.Printf("-- file: %s\n%s", fileName, fileContent)

	return nil
}

